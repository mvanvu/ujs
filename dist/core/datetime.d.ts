export type DateTimeLike = number | string | Date | DateTime;
export type DateTimeUnit = 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';
export declare class DateTime {
    private isValid;
    private offset;
    private date;
    constructor(datetimeLike?: DateTimeLike, offset?: number | string);
    get valid(): boolean;
    get iso(): string;
    get native(): Date;
    get time(): number;
    get tzOffset(): string;
    static parseOffset(offset: number | string): number;
    static from(datetimeLike?: DateTimeLike, offset?: number | string): DateTime;
    static now(offset?: number | string): DateTime;
    static utc(): DateTime;
    static yesterday(offset?: number | string): DateTime;
    static tomorrow(offset?: number | string): DateTime;
    static parse(datetimeLike?: DateTimeLike): false | Date;
    setOffset(offset: number): this;
    utc(): this;
    clone(): DateTime;
    intervalToMilliseconds(interval: number, unit?: DateTimeUnit): number;
    add(interval: number, unit?: DateTimeUnit): this;
    sub(interval: number, unit?: DateTimeUnit): this;
    startOf(): this;
    endOf(): this;
    pad(value: number, number?: number): string;
    format(pattern?: string, locale?: string): string;
    diff(datetime?: DateTimeLike, unit?: DateTimeUnit): number;
    gt(datetime?: DateTimeLike, unit?: DateTimeUnit): boolean;
    gte(datetime?: DateTimeLike, unit?: DateTimeUnit): boolean;
    lt(datetime?: DateTimeLike, unit?: DateTimeUnit): boolean;
    lte(datetime?: DateTimeLike, unit?: DateTimeUnit): boolean;
    eq(datetime?: DateTimeLike, unit?: DateTimeUnit): boolean;
    toString(): string;
    valueOf(): number;
    [Symbol.iterator](): Generator<number, void, unknown>;
}
